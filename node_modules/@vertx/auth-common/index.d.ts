/*
 * Copyright 2020 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

/**
 *
 * User-facing interface for authenticating users.
 */
export abstract class AuthProvider {
  /**
   * Authenticate a user.
   * <p>
   * The first argument is a JSON object containing information for authenticating the user. What this actually contains
   * depends on the specific implementation. In the case of a simple username/password based
   * authentication it is likely to contain a JSON object with the following structure:
   * <pre>
   *   {
   *     "username": "tim",
   *     "password": "mypassword"
   *   }
   * </pre>
   * For other types of authentication it contain different information - for example a JWT token or OAuth bearer token.
   * <p>
   * If the user is successfully authenticated a {@link User} object is passed to the handler in an {@link AsyncResult}.
   * The user object can then be used for authorisation.
   */
  authenticate(authInfo: { [key: string]: any }, resultHandler: ((res: AsyncResult<User>) => void) | Handler<AsyncResult<User>>) : void;
}

/**
 * Chain several auth providers as if they were one. This is useful for cases where one want to authenticate across
 * several providers, for example, database and fallback to passwd file.
 */
export abstract class ChainAuth extends AuthProvider {
  /**
   * Create a Chainable Auth Provider auth provider
   */
  static create() : ChainAuth;

  /**
   * Appends a auth provider to the chain.
   */
  append(other: AuthProvider) : ChainAuth;

  /**
   * Removes a provider from the chain.
   */
  remove(other: AuthProvider) : boolean;

  /**
   * Clears the chain.
   */
  clear() : void;
}

/**
 * Hashing Algorithm. A common interface to interact with any system provided algorithms.
 */
export abstract class HashingAlgorithm {
  /**
   * return the symbolic name for the algorithm
   */
  id() : string;

  /**
   * return the list of param names required for this algorithm.
   */
  params() : string[];

  /**
   * Should the encoded string use the default separator to split fields.
   */
  needsSeparator() : boolean;
}

/**
 * Hashing Strategy manager.
 *
 * This class will load system provided hashing strategies and algorithms.
 */
export abstract class HashingStrategy {
  /**
   * Factory method to load the algorithms from the system
   */
  static load() : HashingStrategy;

  /**
   * Hashes a password.
   */
  hash(id: string, params: { [key: string]: string; }, salt: string, password: string) : string;

  /**
   * Time constant password check. Regardless of the check, this algorithm executes the same number of
   * checks regardless of the correctly number of characters
   */
  verify(hash: string, password: string) : boolean;

  /**
   * Get an algorithm interface by its Id
   */
  get(id: string) : HashingAlgorithm;

  /**
   * Put or replace an algorithm into the list of system loaded algorithms.
   */
  put(id: string, algorithm: HashingAlgorithm) : HashingStrategy;
}

/**
 * Represents an authenticates User and contains operations to authorise the user.
 * <p>
 * Please consult the documentation for a detailed explanation.
 */
export abstract class User {
  /**
   * Is the user authorised to
   */
  isAuthorized(authority: string, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : User;

  /**
   */
  isAuthorised(authority: string, resultHandler: ((res: AsyncResult<boolean>) => void) | Handler<AsyncResult<boolean>>) : User;

  /**
   * The User object will cache any authorities that it knows it has to avoid hitting the
   * underlying auth provider each time.  Use this method if you want to clear this cache.
   */
  clearCache() : User;

  /**
   * Get the underlying principal for the User. What this actually returns depends on the implementation.
   * For a simple user/password based auth, it's likely to contain a JSON object with the following structure:
   * <pre>
   *   {
   *     "username", "tim"
   *   }
   * </pre>
   */
  principal() : { [key: string]: any };

  /**
   * Set the auth provider for the User. This is typically used to reattach a detached User with an AuthProvider, e.g.
   * after it has been deserialized.
   */
  setAuthProvider(authProvider: AuthProvider) : void;
}

import { Vertx } from '@vertx/core';

/**
 * A secure non blocking random number generator isolated to the current context. The PRNG is bound to the vert.x
 * context and setup to close when the context shuts down.
 * <p>
 * When applicable, use of VertxContextPRNG rather than create new PRNG objects is helpful to keep the system entropy
 * usage to the minimum avoiding potential blocking across the application.
 * <p>
 * The use of VertxContextPRNG is particularly appropriate when multiple handlers use random numbers.
 */
export abstract class VertxContextPRNG {
  /**
   * Get or create a secure non blocking random number generator using the current vert.x context. If there is no
   * current context (i.e.: not running on the eventloop) then a IllegalStateException is thrown.
   */
  static current() : VertxContextPRNG;

  /**
   * Get or create a secure non blocking random number generator using the current vert.x instance. Since the context
   * might be different this method will attempt to use the current context first if available and then fall back to
   * create a new instance of the PRNG.
   */
  static current(vertx: Vertx) : VertxContextPRNG;

  /**
   * Returns a Base64 mime encoded String of random data with the given length. The length parameter refers to the length
   * of the String before the encoding step.
   */
  nextString(length: number) : string;

  /**
   * Returns a secure random int
   */
  nextInt() : number;

  /**
   * Returns a secure random int, between 0 (inclusive) and the specified bound (exclusive).
   */
  nextInt(bound: number) : number;
}
