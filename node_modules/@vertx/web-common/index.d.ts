/*
 * Copyright 2020 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

import { Buffer } from '@vertx/core';
import { WriteStream } from '@vertx/core';

/**
 * A codec for encoding and decoding HTTP bodies.
 */
export abstract class BodyCodec<T> {
  /**
   */
  static string() : BodyCodec<string>;

  /**
   * A codec for strings using a specific <code>encoding</code>.
   */
  static string(encoding: string) : BodyCodec<string>;

  /**
   */
  static buffer() : BodyCodec<Buffer>;

  /**
   */
  static jsonObject() : BodyCodec<{ [key: string]: any }>;

  /**
   */
  static jsonArray() : BodyCodec<any[]>;

  /**
   * Create and return a codec for Java objects encoded using Jackson mapper.
   */
  static json<U>(type: any /* TODO: class */) : BodyCodec<U>;

  /**
   */
  static none() : BodyCodec<void>;

  /**
   * Create a codec that buffers the entire body and then apply the <code>decode</code> function and returns the result.
   */
  static create<T>(decode: (arg: Buffer) => T) : BodyCodec<T>;

  /**
   * A body codec that pipes the body to a write stream.
   * <p></p>
   * Same as pipe(stream, true).
   */
  static pipe(stream: WriteStream<Buffer>) : BodyCodec<void>;

  /**
   * A body codec that pipes the body to a write stream.
   */
  static pipe(stream: WriteStream<Buffer>, close: boolean) : BodyCodec<void>;
}

/**
 * A form data part of a {@link MultipartForm}.
 */
export abstract class FormDataPart {
  /**
   */
  name() : string;

  /**
   */
  isAttribute() : boolean;

  /**
   */
  isFileUpload() : boolean;

  /**
   */
  value() : string;

  /**
   */
  filename() : string;

  /**
   */
  pathname() : string;

  /**
   */
  mediaType() : string;

  /**
   */
  isText() : boolean;
}

/**
 * A multipart form.
 */
export abstract class MultipartForm {
  /**
   */
  static create() : MultipartForm;

  /**
   * Add an attribute form data part.
   */
  attribute(name: string, value: string) : MultipartForm;

  /**
   * Add a text file upload form data part.
   */
  textFileUpload(name: string, filename: string, pathname: string, mediaType: string) : MultipartForm;

  /**
   * Add a binary file upload form data part.
   */
  binaryFileUpload(name: string, filename: string, pathname: string, mediaType: string) : MultipartForm;
}

/**
 * A template template uses a specific template and the data in a routing context to render a resource into a buffer.
 * <p>
 * Concrete implementations exist for several well-known template engines.
 */
export abstract class TemplateEngine {
  /**
   * Render the template. Template engines that support partials/fragments should extract the template base path from
   * the template filename up to the last file separator.
   *
   * Some engines support localization, for these engines, there is a predefined key "lang" to specify the language to
   * be used in the localization, the format should follow the standard locale formats e.g.: "en-gb", "pt-br", "en".
   */
  render(context: { [key: string]: any }, templateFileName: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : void;

  /**
   * Returns true if the template template caches template files. If false, then template files are freshly loaded each
   * time they are used.
   */
  isCachingEnabled() : boolean;

  /**
   * Render the template. Template engines that support partials/fragments should extract the template base path from
   * the template filename up to the last file separator.
   *
   * Some engines support localization, for these engines, there is a predefined key "lang" to specify the language to
   * be used in the localization, the format should follow the standard locale formats e.g.: "en-gb", "pt-br", "en".
   */
  render(context: { [key: string]: any; }, templateFileName: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : void;
}

/**
 * Utility API to verify which environment is the web application running.
 *
 * The utility will check initially for the existence of a system property under the name `vertx.mode`,
 * if there is no such property then it will look under the environment variables under the name `VERTX_MODE`.
 *
 * This value will be then used when the API is invoked. By itself this utility will not
 * affect the behavior of your application, however you can use it to simplify your handlers, e.g.:
 *
 * When the development mode is active you can log more information or disable caches.
 */
export abstract class WebEnvironment {
  static readonly SYSTEM_PROPERTY_NAME : string;

  static readonly ENV_VARIABLE_NAME : string;

  /**
   * Will return true if the mode is not null and equals ignoring case the string "dev"
   */
  static development() : boolean;

  /**
   * The current mode from the system properties with fallback to environment variables
   */
  static mode() : string | null;
}
