/*
 * Copyright 2020 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

import { User } from '@vertx/auth-common';

/**
 * Base interface for auth handlers.
 * <p>
 * An auth handler allows your application to provide authentication/authorization support.
 * <p>
 * Auth handler requires a {@link SessionHandler} to be on the routing chain before it.
 */
export interface AuthHandler extends Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

import { AuthProvider } from '@vertx/auth-common';

/**
 * An auth handler that provides HTTP Basic Authentication support.
 */
export abstract class BasicAuthHandler implements AuthHandler, Handler<RoutingContext> {
  /**
   * The default realm to use
   */
  static readonly DEFAULT_REALM : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a basic auth handler
   */
  static create(authProvider: AuthProvider) : AuthHandler;

  /**
   * Create a basic auth handler, specifying realm
   */
  static create(authProvider: AuthProvider, realm: string) : AuthHandler;
}

/**
 * A handler which gathers the entire request body and sets it on the .
 * <p>
 * It also handles HTTP file uploads and can be used to limit body sizes.
 */
export abstract class BodyHandler implements Handler<RoutingContext> {
  /**
   * Default max size for a request body. -1 means unlimited
   */
  static readonly DEFAULT_BODY_LIMIT : number;

  /**
   * Default uploads directory on server for file uploads
   */
  static readonly DEFAULT_UPLOADS_DIRECTORY : string;

  /**
   * Default value of whether form attributes should be merged into request params
   */
  static readonly DEFAULT_MERGE_FORM_ATTRIBUTES : boolean;

  /**
   * Default value of whether uploaded files should be removed after handling the request
   */
  static readonly DEFAULT_DELETE_UPLOADED_FILES_ON_END : boolean;

  /**
   * Default value of whether to pre-allocate the body buffer size according to the content-length HTTP request header
   */
  static readonly DEFAULT_PREALLOCATE_BODY_BUFFER : boolean;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a body handler with defaults
   */
  static create() : BodyHandler;

  /**
   * Create a body handler setting if it should handle file uploads
   */
  static create(handleFileUploads: boolean) : BodyHandler;

  /**
   * Create a body handler and use the given upload directory.
   */
  static create(uploadDirectory: string) : BodyHandler;

  /**
   * Set whether file uploads will be handled
   */
  setHandleFileUploads(handleFileUploads: boolean) : BodyHandler;

  /**
   * Set the maximum body size -1 means unlimited
   */
  setBodyLimit(bodyLimit: number) : BodyHandler;

  /**
   * Set the uploads directory to use
   */
  setUploadsDirectory(uploadsDirectory: string) : BodyHandler;

  /**
   * Set whether form attributes will be added to the request parameters
   */
  setMergeFormAttributes(mergeFormAttributes: boolean) : BodyHandler;

  /**
   * Set whether uploaded files should be removed after handling the request
   */
  setDeleteUploadedFilesOnEnd(deleteUploadedFilesOnEnd: boolean) : BodyHandler;

  /**
   * Pre-allocate the body buffer according to the value parsed from content-length header.
   * The buffer is capped at 64KB
   */
  setPreallocateBodyBuffer(isPreallocateBodyBuffer: boolean) : BodyHandler;
}

import { BaseBridgeEvent } from '@vertx/bridge-common';
import { Future } from '@vertx/core';
import { BridgeEventType } from '@vertx/bridge-common/enums';

/**
 * Represents an event that occurs on the event bus bridge.
 * <p>
 * Please consult the documentation for a full explanation.
 */
export abstract class BridgeEvent extends BaseBridgeEvent {
  complete(arg0: boolean) : void;

  tryComplete(arg0: boolean) : boolean;

  future() : Future<boolean>;

  /**
   * Get the raw JSON message for the event. This will be null for SOCKET_CREATED or SOCKET_CLOSED events as there is
   * no message involved.
   */
  setRawMessage(message: { [key: string]: any }) : BridgeEvent;

  /**
   * Get the SockJSSocket instance corresponding to the event
   */
  socket() : SockJSSocket;
}

/**
 * This handler adds a CSRF token to requests which mutate state. In order change the state a (XSRF-TOKEN) cookie is set
 * with a unique token, that is expected to be sent back in a (X-XSRF-TOKEN) header.
 *
 * The behavior is to check the request body header and cookie for validity.
 *
 * This Handler requires session support, thus should be added somewhere below Session and Body handlers.
 */
export abstract class CSRFHandler implements Handler<RoutingContext> {
  static readonly ERROR_MESSAGE : string;

  static readonly DEFAULT_COOKIE_NAME : string;

  static readonly DEFAULT_COOKIE_PATH : string;

  static readonly DEFAULT_HEADER_NAME : string;

  static readonly DEFAULT_RESPONSE_BODY : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Instantiate a new CSRFHandlerImpl with a secret
   * <p>
   * <pre>
   * CSRFHandler.create("s3cr37")
   * </pre>
   */
  static create(secret: string) : CSRFHandler;

  /**
   * Set the cookie name. By default XSRF-TOKEN is used as it is the expected name by AngularJS however other frameworks
   * might use other names.
   */
  setCookieName(name: string) : CSRFHandler;

  /**
   * Set the cookie path. By default / is used.
   */
  setCookiePath(path: string) : CSRFHandler;

  /**
   * Set the header name. By default X-XSRF-TOKEN is used as it is the expected name by AngularJS however other
   * frameworks might use other names.
   */
  setHeaderName(name: string) : CSRFHandler;

  /**
   * Should the handler give warning messages if this handler is used in other than https protocols?
   */
  setNagHttps(nag: boolean) : CSRFHandler;

  /**
   * Set the body returned by the handler when the XSRF token is missing or invalid.
   */
  setResponseBody(responseBody: string) : CSRFHandler;

  /**
   * Set the timeout for tokens generated by the handler, by default it uses the default from the session handler.
   */
  setTimeout(timeout: number) : CSRFHandler;
}

/**
 * An auth handler that chains to a sequence of handlers.
 */
export abstract class ChainAuthHandler implements AuthHandler, Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  static create() : ChainAuthHandler;

  /**
   * Appends a auth provider to the chain.
   */
  append(authHandler: AuthHandler) : ChainAuthHandler;

  /**
   * Removes a provider from the chain.
   */
  remove(authHandler: AuthHandler) : boolean;

  /**
   * Clears the chain.
   */
  clear() : void;
}

import { Vertx } from '@vertx/core';

/**
 * A session store which stores sessions in a distributed map so they are available across the cluster.
 */
export abstract class ClusteredSessionStore extends SessionStore {
  /**
   * Default length for a session id.
   * More info: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
   */
  static readonly DEFAULT_SESSIONID_LENGTH : number;

  /**
   * The default name used for the session map
   */
  static readonly DEFAULT_SESSION_MAP_NAME : string;

  /**
   * Default retry time out, in ms, for a session not found in this store.
   */
  static readonly DEFAULT_RETRY_TIMEOUT : number;

  /**
   * Create a session store
   */
  static create(vertx: Vertx, sessionMapName: string) : ClusteredSessionStore;

  /**
   * Create a session store.<p/>
   *
   * The retry timeout value, configures how long the session handler will retry to get a session from the store
   * when it is not found.
   */
  static create(vertx: Vertx, sessionMapName: string, retryTimeout: number) : ClusteredSessionStore;

  /**
   * Create a session store
   */
  static create(vertx: Vertx) : ClusteredSessionStore;

  /**
   * Create a session store.<p/>
   *
   * The retry timeout value, configures how long the session handler will retry to get a session from the store
   * when it is not found.
   */
  static create(vertx: Vertx, retryTimeout: number) : ClusteredSessionStore;
}

import { Cookie as CookieSuper } from '@vertx/core';

/**
 * Represents an HTTP Cookie.
 * <p>
 * All cookies must have a name and a value and can optionally have other fields set such as path, domain, etc.
 * <p>
 * (Derived from io.netty.handler.codec.http.Cookie)
 */
export abstract class Cookie extends CookieSuper {
  /**
   * Create a new cookie
   */
  static cookie(name: string, value: string) : Cookie;

  setValue(value: string) : Cookie;

  setDomain(domain: string | null | undefined) : Cookie;

  setPath(path: string | null | undefined) : Cookie;

  setMaxAge(maxAge: number) : Cookie;

  setSecure(secure: boolean) : Cookie;

  setHttpOnly(httpOnly: boolean) : Cookie;

  /**
   * Has the cookie been changed? Changed cookieMap will be saved out in the response and sent to the browser.
   */
  isChanged() : boolean;

  /**
   * Set the cookie as being changed. Changed will be true for a cookie just created, false by default if just
   * read from the request
   */
  setChanged(changed: boolean) : void;

  /**
   * Has this Cookie been sent from the User Agent (the browser)? or was created during the executing on the request.
   */
  isFromUserAgent() : boolean;
}

/**
 * A handler which decodes cookies from the request, makes them available in the 
 * and writes them back in the response.
 *
 * Since 3.8.1 this handler simply calls the next request handler. This handler will be removed in Vert.x 4.
 */
export abstract class CookieHandler implements Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Create a cookie handler
   */
  static create() : CookieHandler;
}

import { HttpMethod } from '@vertx/core/enums';

/**
 * A handler which implements server side http://www.w3.org/TR/cors/[CORS] support for Vert.x-Web.
 */
export abstract class CorsHandler implements Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Create a CORS handler
   */
  static create(allowedOriginPattern: string) : CorsHandler;

  /**
   * Add an allowed method
   */
  allowedMethod(method: HttpMethod) : CorsHandler;

  /**
   * Add a set of  allowed methods
   */
  allowedMethods(methods: HttpMethod[]) : CorsHandler;

  /**
   * Add an allowed header
   */
  allowedHeader(headerName: string) : CorsHandler;

  /**
   * Add a set of allowed headers
   */
  allowedHeaders(headerNames: string[]) : CorsHandler;

  /**
   * Add an exposed header
   */
  exposedHeader(headerName: string) : CorsHandler;

  /**
   * Add a set of exposed headers
   */
  exposedHeaders(headerNames: string[]) : CorsHandler;

  /**
   * Set whether credentials are allowed. Note that user agents will block
   * requests that use a wildcard as origin and include credentials.
   *
   * From the MDN documentation you can read:
   *
   * <blockquote>
   * Important note: when responding to a credentialed request,
   * server must specify a domain, and cannot use wild carding.
   * </blockquote>
   */
  allowCredentials(allow: boolean) : CorsHandler;

  /**
   * Set how long the browser should cache the information
   */
  maxAgeSeconds(maxAgeSeconds: number) : CorsHandler;
}

// @ts-ignore
import { HtdigestAuth } from '@vertx/auth-htdigest';

/**
 * An auth handler that provides HTTP Basic Authentication support.
 */
export abstract class DigestAuthHandler implements AuthHandler, Handler<RoutingContext> {
  /**
   * The default nonce expire timeout to use in milliseconds.
   */
  static readonly DEFAULT_NONCE_EXPIRE_TIMEOUT : number;

  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a digest auth handler
   */
  static create(authProvider: HtdigestAuth) : DigestAuthHandler;

  /**
   * Create a digest auth handler, specifying the expire timeout for nonces.
   */
  static create(authProvider: HtdigestAuth, nonceExpireTimeout: number) : DigestAuthHandler;
}

/**
 * A pretty error handler for rendering error pages. When working in development mode
 * exception details will be returned in the server responses, otherwise or when
 * manually specified no exception details are returned in the HTTP response.
 *
 * The reason the display of the exception details is by default dependent of the mode
 * is to follow the security best practices:
 * <a href="https://www.owasp.org/index.php/Improper_Error_Handling">https://www.owasp.org/index.php/Improper_Error_Handling</a>
 */
export abstract class ErrorHandler implements Handler<RoutingContext> {
  /**
   * The default template to use for rendering
   */
  static readonly DEFAULT_ERROR_HANDLER_TEMPLATE : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Create an error handler using defaults
   */
  static create() : ErrorHandler;

  /**
   * Create an error handler
   */
  static create(errorTemplateName: string, displayExceptionDetails: boolean) : ErrorHandler;

  /**
   * Create an error handler
   */
  static create(displayExceptionDetails: boolean) : ErrorHandler;

  /**
   * Create an error handler
   */
  static create(errorTemplateName: string) : ErrorHandler;
}

/**
 * A handler that serves favicons.
 * <p>
 * If no file system path is specified it will attempt to serve a resource called `favicon.ico` from the classpath.
 */
export abstract class FaviconHandler implements Handler<RoutingContext> {
  /**
   * The default max age in seconds as set in the cache-control header
   */
  static readonly DEFAULT_MAX_AGE_SECONDS : number;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler with defaults
   */
  static create() : FaviconHandler;

  /**
   * Create a handler attempting to load favicon file from the specified path
   */
  static create(path: string) : FaviconHandler;

  /**
   * Create a handler attempting to load favicon file from the specified path, and with the specified max cache time
   */
  static create(path: string, maxAgeSeconds: number) : FaviconHandler;

  /**
   * Create a handler with the specified max cache time
   */
  static create(maxAgeSeconds: number) : FaviconHandler;
}

/**
 * Represents a file-upload from an HTTP multipart form submission.
 * <p>
 */
export abstract class FileUpload {
  /**
   */
  name() : string;

  /**
   */
  uploadedFileName() : string;

  /**
   */
  fileName() : string;

  /**
   */
  size() : number;

  /**
   */
  contentType() : string;

  /**
   */
  contentTransferEncoding() : string;

  /**
   */
  charSet() : string;
}

/**
 * Handler that handles login from a form on a custom login page.
 * <p>
 * Used in conjunction with the {@link RedirectAuthHandler}.
 */
export abstract class FormLoginHandler implements Handler<RoutingContext> {
  /**
   * The default value of the form attribute which will contain the username
   */
  static readonly DEFAULT_USERNAME_PARAM : string;

  /**
   * The default value of the form attribute which will contain the password
   */
  static readonly DEFAULT_PASSWORD_PARAM : string;

  /**
   * The default value of the session attribute which will contain the return url
   */
  static readonly DEFAULT_RETURN_URL_PARAM : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler
   */
  static create(authProvider: AuthProvider) : FormLoginHandler;

  /**
   * Create a handler
   */
  static create(authProvider: AuthProvider, usernameParam: string, passwordParam: string, returnURLParam: string, directLoggedInOKURL: string) : FormLoginHandler;

  /**
   * Set the name of the form param used to submit the username
   */
  setUsernameParam(usernameParam: string) : FormLoginHandler;

  /**
   * Set the name of the form param used to submit the password
   */
  setPasswordParam(passwordParam: string) : FormLoginHandler;

  /**
   * Set the name of the session attrioute used to specify the return url
   */
  setReturnURLParam(returnURLParam: string) : FormLoginHandler;

  /**
   * Set the url to redirect to if the user logs in directly at the url of the form login handler
   * without being redirected here first
   */
  setDirectLoggedInOKURL(directLoggedInOKURL: string) : FormLoginHandler;
}

// @ts-ignore
import { JWTAuth } from '@vertx/auth-jwt';

/**
 * An auth handler that provides JWT Authentication support.
 */
export abstract class JWTAuthHandler implements AuthHandler, Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a JWT auth handler
   */
  static create(authProvider: JWTAuth) : JWTAuthHandler;

  /**
   * Create a JWT auth handler
   */
  static create(authProvider: JWTAuth, skip: string) : JWTAuthHandler;

  /**
   * Set the audience list
   */
  setAudience(audience: string[]) : JWTAuthHandler;

  /**
   * Set the issuer
   */
  setIssuer(issuer: string) : JWTAuthHandler;

  /**
   * Set whether expiration is ignored
   */
  setIgnoreExpiration(ignoreExpiration: boolean) : JWTAuthHandler;
}

/**
 * A parsed language header.
 * Delivers a more direct access to the individual elements of the header it represents
 */
export abstract class LanguageHeader extends Locale implements ParsedHeaderValue {
  /**
   * <quote>If no "q" parameter is present, the default weight is 1.</quote>
   */
  static readonly DEFAULT_WEIGHT : number;

  /**
   * Contains the raw value that was received from the user agent
   */
  rawValue() : string;

  /**
   * Holds the unparsed value of the header.<br>
   * For the most part, this is the content before the semi-colon (";")
   */
  value() : string;

  /**
   * Holds the weight specified in the "q" parameter of the header.<br>
   * If the parameter is not specified, 1.0 is assumed according to
   * <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">rfc7231</a>
   */
  weight() : number;

  /**
   * The value of the parameter specified by this key. Each is one of 3 things:
   * <ol>
   * <li>null &lt;- That key was not specified</li>
   * <li>ParsedHeaderValue.EMPTY (tested using ==) &lt;- The value was not specified</li>
   * <li>[Other] <- The value of the parameter</li>
   * </ol>
   * <b>Note:</b> The <code>q</code> parameter is never present.
   */
  parameter(key: string) : string | null;

  /**
   * The parameters specified in this header value.
   * <b>Note:</b> The <code>q</code> parameter is never present.
   */
  parameters() : { [key: string]: string; };

  /**
   * Is this an allowed operation as specified by the corresponding header?
   */
  isPermitted() : boolean;

  /**
   * Test if this header is matched by matchTry header
   */
  isMatchedBy(matchTry: ParsedHeaderValue) : boolean;

  /**
   * An integer that represents the absolute order position of this header
   */
  weightedOrder() : number;

  /**
   * The tag of the language as specified by
   * <a href="https://tools.ietf.org/html/rfc7231#section-3.1.3.1">rfc7231#section-3.1.3.1</a>.<br>
   * Equivalent to 
   */
  tag() : string;

  /**
   * The subtag of the language as specified by
   * <a href="https://tools.ietf.org/html/rfc7231#section-3.1.3.1">rfc7231#section-3.1.3.1</a>.<br>
   * Equivalent to 
   */
  subtag() : string | null;

  /**
   * A subtag of this language header.<br>
   * + info: <a href="https://tools.ietf.org/html/rfc7231#section-3.1.3.1">rfc7231#section-3.1.3.1</a>
   */
  subtag(level: number) : string | null;

  /**
   */
  subtagCount() : number;
}

/**
 * A session store which is only available on a single node.
 * <p>
 * Can be used when sticky sessions are being used.
 */
export abstract class LocalSessionStore extends SessionStore {
  /**
   * Default length for a session id.
   * More info: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
   */
  static readonly DEFAULT_SESSIONID_LENGTH : number;

  /**
   * Default of how often, in ms, to check for expired sessions
   */
  static readonly DEFAULT_REAPER_INTERVAL : number;

  /**
   * Default name for map used to store sessions
   */
  static readonly DEFAULT_SESSION_MAP_NAME : string;

  /**
   * Create a session store
   */
  static create(vertx: Vertx) : LocalSessionStore;

  /**
   * Create a session store
   */
  static create(vertx: Vertx, sessionMapName: string) : LocalSessionStore;

  /**
   * Create a session store
   */
  static create(vertx: Vertx, sessionMapName: string, reaperInterval: number) : LocalSessionStore;
}

/**
 */
export abstract class Locale {
  static create() : Locale;

  static create(language: string) : Locale;

  static create(language: string, country: string) : Locale;

  static create(language: string, country: string, variant: string) : Locale;

  /**
   * Returns the language as reported by the HTTP client.
   */
  language() : string;

  /**
   * Returns the country as reported by the HTTP client.
   */
  country() : string;

  /**
   * Returns the variant as reported by the HTTP client.
   */
  variant() : string;
}

import { LoggerFormat } from './enums';

/**
 * A handler which logs request information to the Vert.x logger.
 * You should mount this handler before any handler that could fail the routing context
 */
export abstract class LoggerHandler implements Handler<RoutingContext> {
  static readonly DEFAULT_FORMAT : LoggerFormat;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler with default format
   */
  static create() : LoggerHandler;

  /**
   * Create a handler with he specified format
   */
  static create(format: LoggerFormat) : LoggerHandler;

  /**
   * Create a handler with he specified format
   */
  static create(immediate: boolean, format: LoggerFormat) : LoggerHandler;
}

export abstract class MIMEHeader implements ParsedHeaderValue {
  /**
   * <quote>If no "q" parameter is present, the default weight is 1.</quote>
   */
  static readonly DEFAULT_WEIGHT : number;

  /**
   * Contains the raw value that was received from the user agent
   */
  rawValue() : string;

  /**
   * Holds the unparsed value of the header.<br>
   * For the most part, this is the content before the semi-colon (";")
   */
  value() : string;

  /**
   * Holds the weight specified in the "q" parameter of the header.<br>
   * If the parameter is not specified, 1.0 is assumed according to
   * <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">rfc7231</a>
   */
  weight() : number;

  /**
   * The value of the parameter specified by this key. Each is one of 3 things:
   * <ol>
   * <li>null &lt;- That key was not specified</li>
   * <li>ParsedHeaderValue.EMPTY (tested using ==) &lt;- The value was not specified</li>
   * <li>[Other] <- The value of the parameter</li>
   * </ol>
   * <b>Note:</b> The <code>q</code> parameter is never present.
   */
  parameter(key: string) : string | null;

  /**
   * The parameters specified in this header value.
   * <b>Note:</b> The <code>q</code> parameter is never present.
   */
  parameters() : { [key: string]: string; };

  /**
   * Is this an allowed operation as specified by the corresponding header?
   */
  isPermitted() : boolean;

  /**
   * Test if this header is matched by matchTry header
   */
  isMatchedBy(matchTry: ParsedHeaderValue) : boolean;

  /**
   * An integer that represents the absolute order position of this header
   */
  weightedOrder() : number;

  /**
   * Gets the parsed component part of the MIME. This is the string between the beginning and the first <code>'/'</code>
   * of the MIME
   */
  component() : string;

  /**
   * Gets the parsed subcomponent part of the MIME. This is the string between the first <code>'/'</code> and the
   * <code>';'</code> or the end of the MIME
   */
  subComponent() : string;
}

/**
 * A handler which selectively executes another handler if a precondition is met.
 *
 * There are cases where applications are build as multi tenant, in this cases one of the
 * common tasks is to configure different authentication mechanisms for each tenant.
 *
 * This handler will allow registering any other handler and will only execute it if
 * the precondition is met. There are 2 way of defining a precondition:
 *
 * <ul>
 *     <li>A http header value for example <pre>X-Tenant</pre></li>
 *     <li>A custom extractor function that can return a String from the context</li>
 * </ul>
 *
 * Requests that pass the validation will contain a new key in the routing context with
 * the tenant id, for the case of being a default handler the value if this key will be "default".
 */
export abstract class MultiTenantHandler implements Handler<RoutingContext> {
  /**
   * The default key used to identify a tenant in the context data.
   */
  static readonly TENANT : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a MultiTenant handler that will extract the tenant id from a given header name.
   */
  static create(header: string) : MultiTenantHandler;

  /**
   * Create a MultiTenant handler using a custom tenant extraction function.
   */
  static create(tenantExtractor: (arg: RoutingContext) => string) : MultiTenantHandler;

  /**
   * Create a MultiTenant handler using a custom tenant extraction function.
   */
  static create(tenantExtractor: (arg: RoutingContext) => string, contextKey: string) : MultiTenantHandler;

  /**
   * Add a handler for a given tenant to this handler.
   *
   * Both tenant and handler cannot be null.
   */
  addTenantHandler(tenant: string, handler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : MultiTenantHandler;

  /**
   * Remove a handler for a given tenant from this handler.
   *
   * Tenant cannot be null.
   */
  removeTenant(tenant: string) : MultiTenantHandler;

  /**
   * Add a default handler for the case when no tenant was matched.
   *
   * The handler cannot be null.
   */
  addDefaultHandler(handler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : MultiTenantHandler;
}

// @ts-ignore
import { OAuth2Auth } from '@vertx/auth-oauth2';

/**
 * An auth handler that provides OAuth2 Authentication support. This handler is suitable for AuthCode flows.
 */
export abstract class OAuth2AuthHandler implements AuthHandler, Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a OAuth2 auth handler with host pinning
   */
  static create(authProvider: OAuth2Auth, callbackURL: string) : OAuth2AuthHandler;

  /**
   * Create a OAuth2 auth handler without host pinning.
   * Most providers will not look to the redirect url but always redirect to
   * the preconfigured callback. So this factory does not provide a callback url.
   */
  static create(authProvider: OAuth2Auth) : OAuth2AuthHandler;

  /**
   * Extra parameters needed to be passed while requesting a token.
   */
  extraParams(extraParams: { [key: string]: any }) : OAuth2AuthHandler;

  /**
   * add the callback handler to a given route.
   */
  setupCallback(route: Route) : OAuth2AuthHandler;
}

export interface ParsedHeaderValue {
  /**
   * Contains the raw value that was received from the user agent
   */
  rawValue() : string;

  /**
   * Holds the unparsed value of the header.<br>
   * For the most part, this is the content before the semi-colon (";")
   */
  value() : string;

  /**
   * Holds the weight specified in the "q" parameter of the header.<br>
   * If the parameter is not specified, 1.0 is assumed according to
   * <a href="https://tools.ietf.org/html/rfc7231#section-5.3.1">rfc7231</a>
   */
  weight() : number;

  /**
   * The value of the parameter specified by this key. Each is one of 3 things:
   * <ol>
   * <li>null &lt;- That key was not specified</li>
   * <li>ParsedHeaderValue.EMPTY (tested using ==) &lt;- The value was not specified</li>
   * <li>[Other] <- The value of the parameter</li>
   * </ol>
   * <b>Note:</b> The <code>q</code> parameter is never present.
   */
  parameter(key: string) : string | null;

  /**
   * The parameters specified in this header value.
   * <b>Note:</b> The <code>q</code> parameter is never present.
   */
  parameters() : { [key: string]: string; };

  /**
   * Is this an allowed operation as specified by the corresponding header?
   */
  isPermitted() : boolean;

  /**
   * Test if this header is matched by matchTry header
   */
  isMatchedBy(matchTry: ParsedHeaderValue) : boolean;

  /**
   * An integer that represents the absolute order position of this header
   */
  weightedOrder() : number;
}

export abstract class ParsedHeaderValue implements ParsedHeaderValue {
  /**
   * <quote>If no "q" parameter is present, the default weight is 1.</quote>
   */
  static readonly DEFAULT_WEIGHT : number;
}

/**
 * A container with the request's headers that are meaningful enough to be parsed
 * Contains:
 * <ul>
 * <li>Accept -> MIME header, parameters and sortable</li>
 * <li>Accept-Charset -> Parameters and sortable</li>
 * <li>Accept-Encoding -> Parameters and sortable</li>
 * <li>Accept-Language -> Parameters and sortable</li>
 * <li>Content-Type -> MIME header and parameters</li>
 * </ul>
 *
 */
export abstract class ParsedHeaderValues {
  /**
   */
  accept() : MIMEHeader[];

  /**
   */
  acceptCharset() : ParsedHeaderValue[];

  /**
   */
  acceptEncoding() : ParsedHeaderValue[];

  /**
   */
  acceptLanguage() : LanguageHeader[];

  /**
   */
  contentType() : MIMEHeader;
}

/**
 * An auth handler that's used to handle auth by redirecting user to a custom login page.
 */
export abstract class RedirectAuthHandler implements AuthHandler, Handler<RoutingContext> {
  /**
   * Default path the user will be redirected to
   */
  static readonly DEFAULT_LOGIN_REDIRECT_URL : string;

  /**
   * Default name of param used to store return url information in session
   */
  static readonly DEFAULT_RETURN_URL_PARAM : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Add a required authority for this auth handler
   */
  addAuthority(authority: string) : AuthHandler;

  /**
   * Add a set of required authorities for this auth handler
   */
  addAuthorities(authorities: string[]) : AuthHandler;

  /**
   * Parses the credentials from the request into a JsonObject. The implementation should
   * be able to extract the required info for the auth provider in the format the provider
   * expects.
   */
  parseCredentials(context: RoutingContext, handler: ((res: AsyncResult<{ [key: string]: any }>) => void) | Handler<AsyncResult<{ [key: string]: any }>>) : void;

  /**
   * Authorizes the given user against all added authorities.
   */
  authorize(user: User, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Create a handler
   */
  static create(authProvider: AuthProvider) : AuthHandler;

  /**
   * Create a handler
   */
  static create(authProvider: AuthProvider, loginRedirectURL: string) : AuthHandler;

  /**
   * Create a handler
   */
  static create(authProvider: AuthProvider, loginRedirectURL: string, returnURLParam: string) : AuthHandler;
}

/**
 * A handler which sets the response content type automatically according to the best <code>Accept</code> header match.
 *
 * The header is set only if:
 * <ul>
 * <li>no object is stored in the routing context under the name DEFAULT_DISABLE_FLAG</li>
 * <li>a match is found</li>
 * <li>the header is not present already</li>
 * <li>content length header is absent or set to something different than zero</li>
 * </ul>
 */
export abstract class ResponseContentTypeHandler implements Handler<RoutingContext> {
  static readonly DEFAULT_DISABLE_FLAG : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a response content type handler.
   */
  static create() : ResponseContentTypeHandler;

  /**
   * Create a response content type handler with a custom disable flag.
   */
  static create(disableFlag: string) : ResponseContentTypeHandler;
}

/**
 * Handler which adds a header `x-response-time` in the response of matching requests containing the time taken
 * in ms to process the request.
 */
export abstract class ResponseTimeHandler implements Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler
   */
  static create() : ResponseTimeHandler;
}

/**
 * A route is a holder for a set of criteria which determine whether an HTTP request or failure should be routed
 * to a handler.
 */
export abstract class Route {
  /**
   * Add an HTTP method for this route. By default a route will match all HTTP methods. If any are specified then the route
   * will only match any of the specified methods
   */
  method(method: HttpMethod) : Route;

  /**
   * Set the path prefix for this route. If set then this route will only match request URI paths which start with this
   * path prefix. Only a single path or path regex can be set for a route.
   */
  path(path: string) : Route;

  /**
   * Set the path prefix as a regular expression. If set then this route will only match request URI paths, the beginning
   * of which match the regex. Only a single path or path regex can be set for a route.
   */
  pathRegex(path: string) : Route;

  /**
   * Add a content type produced by this route. Used for content based routing.
   */
  produces(contentType: string) : Route;

  /**
   * Add a content type consumed by this route. Used for content based routing.
   */
  consumes(contentType: string) : Route;

  /**
   * Specify the order for this route. The router tests routes in that order.
   */
  order(order: number) : Route;

  /**
   * Specify this is the last route for the router.
   */
  last() : Route;

  /**
   * Append a request handler to the route handlers list. The router routes requests to handlers depending on whether the various
   * criteria such as method, path, etc match. When method, path, etc are the same for different routes, You should add multiple
   * handlers to the same route object rather than creating two different routes objects with one handler for route
   */
  handler(requestHandler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : Route;

  /**
   * Like {@link Route#blockingHandler} called with ordered = true
   */
  blockingHandler(requestHandler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : Route;

  /**
   * Use a (sub) {@link Router} as a handler. There are several requirements to be fulfilled for this
   * to be accepted.
   *
   * <ul>
   *     <li>The route path must end with a wild card</li>
   *     <li>Parameters are allowed but full regex patterns not</li>
   *     <li>No other handler can be registered before or after this call (but they can on a new route object for the same path)</li>
   *     <li>Only 1 router per path object</li>
   * </ul>
   */
  subRouter(subRouter: Router) : Route;

  /**
   * Specify a blocking request handler for the route.
   * This method works just like {@link Route#handler} excepted that it will run the blocking handler on a worker thread
   * so that it won't block the event loop. Note that it's safe to call context.next() from the
   * blocking handler as it will be executed on the event loop context (and not on the worker thread.
   *
   * If the blocking handler is ordered it means that any blocking handlers for the same context are never executed
   * concurrently but always in the order they were called. The default value of ordered is true. If you do not want this
   * behaviour and don't mind if your blocking handlers are executed in parallel you can set ordered to false.
   */
  blockingHandler(requestHandler: ((res: RoutingContext) => void) | Handler<RoutingContext>, ordered: boolean) : Route;

  /**
   * Append a failure handler to the route failure handlers list. The router routes failures to failurehandlers depending on whether the various
   * criteria such as method, path, etc match. When method, path, etc are the same for different routes, You should add multiple
   * failure handlers to the same route object rather than creating two different routes objects with one failure handler for route
   */
  failureHandler(failureHandler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : Route;

  /**
   * Remove this route from the router
   */
  remove() : Route;

  /**
   * Disable this route. While disabled the router will not route any requests or failures to it.
   */
  disable() : Route;

  /**
   * Enable this route.
   */
  enable() : Route;

  /**
   * If true then the normalised request path will be used when routing (e.g. removing duplicate /)
   * Default is true
   */
  useNormalisedPath(useNormalisedPath: boolean) : Route;

  /**
   */
  getPath() : string | null;

  /**
   * Returns true of the path is a regular expression, this includes expression paths.
   */
  isRegexPath() : boolean;

  /**
   */
  methods() : HttpMethod[];

  /**
   * When you add a new route with a regular expression, you can add named capture groups for parameters. <br/>
   * However, if you need more complex parameters names (like "param_name"), you can add parameters names with
   * this function. You have to name capture groups in regex with names: "p0", "p1", "p2", ... <br/>
   * <br/>
   * For example: If you declare route with regex \/(?<p0>[a-z]*)\/(?<p1>[a-z]*) and group names ["param_a", "param-b"]
   * for uri /hello/world you receive inside pathParams() the parameter param_a = "hello"
   */
  setRegexGroupsNames(groups: string[]) : Route;
}

import { HttpServerRequest } from '@vertx/core';

/**
 * A router receives request from an {@link HttpServer} and routes it to the first matching
 * {@link Route} that it contains. A router can contain many routes.
 * <p>
 * Routers are also used for routing failures.
 */
export abstract class Router implements Handler<HttpServerRequest> {
  handle(arg0: HttpServerRequest) : void;

  /**
   * Create a router
   */
  static router(vertx: Vertx) : Router;

  /**
   * This method is used to provide a request to the router. Usually you take request from the
   * {@link HttpServer#requestHandler} and pass it to this method. The
   * router then routes it to matching routes.
   *
   * This method is now deprecated you can use this object directly as a request handler, which
   * means there is no need for a method reference anymore.
   */
  accept(request: HttpServerRequest) : void;

  /**
   * Add a route with no matching criteria, i.e. it matches all requests or failures.
   */
  route() : Route;

  /**
   * Add a route that matches the specified HTTP method and path
   */
  route(method: HttpMethod, path: string) : Route;

  /**
   * Add a route that matches the specified path
   */
  route(path: string) : Route;

  /**
   * Add a route that matches the specified HTTP method and path regex
   */
  routeWithRegex(method: HttpMethod, regex: string) : Route;

  /**
   * Add a route that matches the specified path regex
   */
  routeWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP GET request
   */
  get() : Route;

  /**
   * Add a route that matches a HTTP GET request and the specified path
   */
  get(path: string) : Route;

  /**
   * Add a route that matches a HTTP GET request and the specified path regex
   */
  getWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP HEAD request
   */
  head() : Route;

  /**
   * Add a route that matches a HTTP HEAD request and the specified path
   */
  head(path: string) : Route;

  /**
   * Add a route that matches a HTTP HEAD request and the specified path regex
   */
  headWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP OPTIONS request
   */
  options() : Route;

  /**
   * Add a route that matches a HTTP OPTIONS request and the specified path
   */
  options(path: string) : Route;

  /**
   * Add a route that matches a HTTP OPTIONS request and the specified path regex
   */
  optionsWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP PUT request
   */
  put() : Route;

  /**
   * Add a route that matches a HTTP PUT request and the specified path
   */
  put(path: string) : Route;

  /**
   * Add a route that matches a HTTP PUT request and the specified path regex
   */
  putWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP POST request
   */
  post() : Route;

  /**
   * Add a route that matches a HTTP POST request and the specified path
   */
  post(path: string) : Route;

  /**
   * Add a route that matches a HTTP POST request and the specified path regex
   */
  postWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP DELETE request
   */
  delete() : Route;

  /**
   * Add a route that matches a HTTP DELETE request and the specified path
   */
  delete(path: string) : Route;

  /**
   * Add a route that matches a HTTP DELETE request and the specified path regex
   */
  deleteWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP TRACE request
   */
  trace() : Route;

  /**
   * Add a route that matches a HTTP TRACE request and the specified path
   */
  trace(path: string) : Route;

  /**
   * Add a route that matches a HTTP TRACE request and the specified path regex
   */
  traceWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP CONNECT request
   */
  connect() : Route;

  /**
   * Add a route that matches a HTTP CONNECT request and the specified path
   */
  connect(path: string) : Route;

  /**
   * Add a route that matches a HTTP CONNECT request and the specified path regex
   */
  connectWithRegex(regex: string) : Route;

  /**
   * Add a route that matches any HTTP PATCH request
   */
  patch() : Route;

  /**
   * Add a route that matches a HTTP PATCH request and the specified path
   */
  patch(path: string) : Route;

  /**
   * Add a route that matches a HTTP PATCH request and the specified path regex
   */
  patchWithRegex(regex: string) : Route;

  /**
   */
  getRoutes() : Route[];

  /**
   * Remove all the routes from this router
   */
  clear() : Router;

  /**
   * Mount a sub router on this router
   */
  mountSubRouter(mountPoint: string, subRouter: Router) : Router;

  /**
   * Specify a handler for any unhandled exceptions on this router. The handler will be called for exceptions thrown
   * from handlers. This does not affect the normal failure routing logic.
   */
  exceptionHandler(exceptionHandler: ((res: Error) => void) | Handler<Error> | null | undefined) : Router;

  /**
   * Specify an handler to handle an error for a particular status code. You can use to manage general errors too using status code 500.
   * The handler will be called when the context fails and other failure handlers didn't write the reply or when an exception is thrown inside an handler.
   * You <b>must not</b> use {@link RoutingContext#next} inside the error handler
   * This does not affect the normal failure routing logic.
   */
  errorHandler(statusCode: number, errorHandler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : Router;

  /**
   * Used to route a context to the router. Used for sub-routers. You wouldn't normally call this method directly.
   */
  handleContext(context: RoutingContext) : void;

  /**
   * Used to route a failure to the router. Used for sub-routers. You wouldn't normally call this method directly.
   */
  handleFailure(context: RoutingContext) : void;

  /**
   * When a Router routes are changed this handler is notified.
   * This is useful for routes that depend on the state of the router.
   */
  modifiedHandler(handler: ((res: Router) => void) | Handler<Router>) : Router;
}

import { MultiMap } from '@vertx/core';
import { Buffer } from '@vertx/core';
import { HttpServerResponse } from '@vertx/core';

/**
 * Represents the context for the handling of a request in Vert.x-Web.
 * <p>
 * A new instance is created for each HTTP request that is received in the
 * {@link Handler#handle} of the router.
 * <p>
 * The same instance is passed to any matching request or failure handlers during the routing of the request or
 * failure.
 * <p>
 * The context provides access to the  and 
 * and allows you to maintain arbitrary data that lives for the lifetime of the context. Contexts are discarded once they
 * have been routed to the handler for the request.
 * <p>
 * The context also provides access to the {@link Session}, cookies and body for the request, given the correct handlers
 * in the application.
 * <p>
 * If you use the internal error handler
 */
export abstract class RoutingContext {
  /**
   */
  request() : HttpServerRequest;

  /**
   */
  response() : HttpServerResponse;

  /**
   * Tell the router to route this context to the next matching route (if any).
   * This method, if called, does not need to be called during the execution of the handler, it can be called
   * some arbitrary time later, if required.
   * <p>
   * If next is not called for a handler then the handler should make sure it ends the response or no response
   * will be sent.
   */
  next() : void;

  /**
   * Fail the context with the specified status code.
   * <p>
   * This will cause the router to route the context to any matching failure handlers for the request. If no failure handlers
   * match It will trigger the error handler matching the status code. You can define such error handler with
   * {@link Router#errorHandler}. If no error handler is not defined, It will send a default failure response with provided status code.
   */
  fail(statusCode: number) : void;

  /**
   * Fail the context with the specified throwable and 500 status code.
   * <p>
   * This will cause the router to route the context to any matching failure handlers for the request. If no failure handlers
   * match It will trigger the error handler matching the status code. You can define such error handler with
   * {@link Router#errorHandler}. If no error handler is not defined, It will send a default failure response with 500 status code.
   */
  fail(throwable: Error) : void;

  /**
   * Fail the context with the specified throwable and the specified the status code.
   * <p>
   * This will cause the router to route the context to any matching failure handlers for the request. If no failure handlers
   * match It will trigger the error handler matching the status code. You can define such error handler with
   * {@link Router#errorHandler}. If no error handler is not defined, It will send a default failure response with provided status code.
   */
  fail(statusCode: number, throwable: Error) : void;

  /**
   * Put some arbitrary data in the context. This will be available in any handlers that receive the context.
   */
  put(key: string, obj: any) : RoutingContext;

  /**
   * Get some data from the context. The data is available in any handlers that receive the context.
   */
  get<T>(key: string) : T;

  /**
   * Remove some data from the context. The data is available in any handlers that receive the context.
   */
  remove<T>(key: string) : T;

  /**
   */
  vertx() : Vertx;

  /**
   */
  mountPoint() : string | null;

  /**
   */
  currentRoute() : Route;

  /**
   * Return the normalised path for the request.
   * <p>
   * The normalised path is where the URI path has been decoded, i.e. any unicode or other illegal URL characters that
   * were encoded in the original URL with `%` will be returned to their original form. E.g. `%20` will revert to a space.
   * Also `+` reverts to a space in a query.
   * <p>
   * The normalised path will also not contain any `..` character sequences to prevent resources being accessed outside
   * of the permitted area.
   * <p>
   * It's recommended to always use the normalised path as opposed to 
   * if accessing server resources requested by a client.
   */
  normalisedPath() : string;

  /**
   * Get the cookie with the specified name.
   */
  getCookie(name: string) : Cookie | null;

  /**
   * Add a cookie. This will be sent back to the client in the response.
   */
  addCookie(cookie: Cookie) : RoutingContext;

  /**
   * Expire a cookie, notifying a User Agent to remove it from its cookie jar.
   */
  removeCookie(name: string) : Cookie | null;

  /**
   * Remove a cookie from the cookie set. If invalidate is true then it will expire a cookie, notifying a User Agent to
   * remove it from its cookie jar.
   */
  removeCookie(name: string, invalidate: boolean) : Cookie | null;

  /**
   */
  cookieCount() : number;

  /**
   */
  cookies() : Cookie[];

  /**
   */
  getBodyAsString() : string | null;

  /**
   * Get the entire HTTP request body as a string, assuming the specified encoding. The context must have first been routed to a
   * {@link BodyHandler} for this to be populated.
   */
  getBodyAsString(encoding: string) : string | null;

  /**
   */
  getBodyAsJson() : { [key: string]: any } | null;

  /**
   */
  getBodyAsJsonArray() : any[] | null;

  /**
   */
  getBody() : Buffer | null;

  /**
   */
  fileUploads() : FileUpload[];

  /**
   * Get the session. The context must have first been routed to a {@link SessionHandler}
   * for this to be populated.
   * Sessions live for a browser session, and are maintained by session cookies.
   */
  session() : Session | null;

  /**
   * Get the authenticated user (if any). This will usually be injected by an auth handler if authentication if successful.
   */
  user() : User | null;

  /**
   * If the context is being routed to failure handlers after a failure has been triggered by calling
   * {@link RoutingContext#fail} then this will return that throwable. It can be used by failure handlers to render a response,
   * e.g. create a failure response page.
   */
  failure() : Error | null;

  /**
   * If the context is being routed to failure handlers after a failure has been triggered by calling
   * {@link RoutingContext#fail}  then this will return that status code.  It can be used by failure handlers to render a response,
   * e.g. create a failure response page.
   *
   * When the status code has not been set yet (it is undefined) its value will be -1.
   */
  statusCode() : number;

  /**
   * If the route specifies produces matches, e.g. produces `text/html` and `text/plain`, and the `accept` header
   * matches one or more of these then this returns the most acceptable match.
   */
  getAcceptableContentType() : string | null;

  /**
   * The headers:
   * <ol>
   * <li>Accept</li>
   * <li>Accept-Charset</li>
   * <li>Accept-Encoding</li>
   * <li>Accept-Language</li>
   * <li>Content-Type</li>
   * </ol>
   * Parsed into {@link ParsedHeaderValue}
   */
  parsedHeaders() : ParsedHeaderValues;

  /**
   * Add a handler that will be called just before headers are written to the response. This gives you a hook where
   * you can write any extra headers before the response has been written when it will be too late.
   */
  addHeadersEndHandler(handler: ((res: void) => void) | Handler<void>) : number;

  /**
   * Remove a headers end handler
   */
  removeHeadersEndHandler(handlerID: number) : boolean;

  /**
   * Provides a handler that will be called after the last part of the body is written to the wire.
   * The handler is called asynchronously of when the response has been received by the client.
   * This provides a hook allowing you to do more operations once the request has been sent over the wire.
   * Do not use this for resource cleanup as this handler might never get called (e.g. if the connection is reset).
   */
  addBodyEndHandler(handler: ((res: void) => void) | Handler<void>) : number;

  /**
   * Remove a body end handler
   */
  removeBodyEndHandler(handlerID: number) : boolean;

  /**
   */
  failed() : boolean;

  /**
   * Set the body. Used by the {@link BodyHandler}. You will not normally call this method.
   */
  setBody(body: Buffer) : void;

  /**
   * Set the session. Used by the {@link SessionHandler}. You will not normally call this method.
   */
  setSession(session: Session) : void;

  /**
   * Set the user. Usually used by auth handlers to inject a User. You will not normally call this method.
   */
  setUser(user: User) : void;

  /**
   * Clear the current user object in the context. This usually is used for implementing a log out feature, since the
   * current user is unbounded from the routing context.
   */
  clearUser() : void;

  /**
   * Set the acceptable content type. Used by
   */
  setAcceptableContentType(contentType: string | null | undefined) : void;

  /**
   * Restarts the current router with a new path and reusing the original method. All path parameters are then parsed
   * and available on the params list. Query params will also be allowed and available.
   */
  reroute(path: string) : void;

  /**
   * Restarts the current router with a new method and path. All path parameters are then parsed and available on the
   * params list. Query params will also be allowed and available.
   */
  reroute(method: HttpMethod, path: string) : void;

  /**
   * Returns the locales for the current request. The locales are determined from the `accept-languages` header and
   * sorted on quality.
   *
   * When 2 or more entries have the same quality then the order used to return the best match is based on the lowest
   * index on the original list. For example if a user has en-US and en-GB with same quality and this order the best
   * match will be en-US because it was declared as first entry by the client.
   */
  acceptableLocales() : Locale[];

  /**
   * Returns the languages for the current request. The languages are determined from the <code>Accept-Language</code>
   * header and sorted on quality.
   *
   * When 2 or more entries have the same quality then the order used to return the best match is based on the lowest
   * index on the original list. For example if a user has en-US and en-GB with same quality and this order the best
   * match will be en-US because it was declared as first entry by the client.
   */
  acceptableLanguages() : LanguageHeader[];

  /**
   * Helper to return the user preferred locale. It is the same action as returning the first element of the acceptable
   * locales.
   */
  preferredLocale() : Locale;

  /**
   * Helper to return the user preferred language.
   * It is the same action as returning the first element of the acceptable languages.
   */
  preferredLanguage() : LanguageHeader;

  /**
   * Returns a map of named parameters as defined in path declaration with their actual values
   */
  pathParams() : { [key: string]: string; };

  /**
   * Gets the value of a single path parameter
   */
  pathParam(name: string) : string | null;

  /**
   * Returns a map of all query parameters inside the <a href="https://en.wikipedia.org/wiki/Query_string">query string</a><br/>
   * The query parameters are lazily decoded: the decoding happens on the first time this method is called. If the query string is invalid
   * it fails the context
   */
  queryParams() : MultiMap;

  /**
   * Gets the value of a single query parameter. For more info {@link RoutingContext#queryParams}
   */
  queryParam(name: string) : string[];

  /**
   */
  data() : { [key: string]: any; };
}

/**
 * Represents a browser session.
 * <p>
 * Sessions persist between HTTP requests for a single browser session. They are deleted when the browser is closed, or
 * they time-out. Session cookies are used to maintain sessions using a secure UUID.
 * <p>
 * Sessions can be used to maintain data for a browser session, e.g. a shopping basket.
 * <p>
 * The context must have first been routed to a {@link SessionHandler}
 * for sessions to be available.
 */
export abstract class Session {
  /**
   */
  regenerateId() : Session;

  /**
   */
  id() : string;

  /**
   * Put some data in a session
   */
  put(key: string, obj: any) : Session;

  /**
   * Get some data from the session
   */
  get<T>(key: string) : T;

  /**
   * Remove some data from the session
   */
  remove<T>(key: string) : T;

  /**
   */
  isEmpty() : boolean;

  /**
   */
  lastAccessed() : number;

  /**
   * Destroy the session
   */
  destroy() : void;

  /**
   */
  isDestroyed() : boolean;

  /**
   */
  isRegenerated() : boolean;

  /**
   */
  oldId() : string;

  /**
   */
  timeout() : number;

  /**
   * Mark the session as being accessed.
   */
  setAccessed() : void;

  /**
   * The short representation of the session to be added to the session cookie. By default is the session id.
   */
  value() : string;

  /**
   */
  data() : { [key: string]: any; };
}

/**
 * A handler that maintains a {@link Session} for each browser
 * session.
 * <p>
 * It looks up the session for each request based on a session cookie which
 * contains a session ID. It stores the session when the response is ended in
 * the session store.
 * <p>
 * The session is available on the routing context with
 * .
 */
export abstract class SessionHandler implements Handler<RoutingContext> {
  /**
   * Default name of session cookie
   */
  static readonly DEFAULT_SESSION_COOKIE_NAME : string;

  /**
   * Default path of session cookie
   */
  static readonly DEFAULT_SESSION_COOKIE_PATH : string;

  /**
   * Default time, in ms, that a session lasts for without being accessed before
   * expiring.
   */
  static readonly DEFAULT_SESSION_TIMEOUT : number;

  /**
   * Default of whether a nagging log warning should be written if the session
   * handler is accessed over HTTP, not HTTPS
   */
  static readonly DEFAULT_NAG_HTTPS : boolean;

  /**
   * Default of whether the cookie has the HttpOnly flag set More info:
   * https://www.owasp.org/index.php/HttpOnly
   */
  static readonly DEFAULT_COOKIE_HTTP_ONLY_FLAG : boolean;

  /**
   * Default of whether the cookie has the 'secure' flag set to allow transmission
   * over https only. More info: https://www.owasp.org/index.php/SecureFlag
   */
  static readonly DEFAULT_COOKIE_SECURE_FLAG : boolean;

  /**
   * Default min length for a session id. More info:
   * https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
   */
  static readonly DEFAULT_SESSIONID_MIN_LENGTH : number;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a session handler
   */
  static create(sessionStore: SessionStore) : SessionHandler;

  /**
   * Set the session timeout
   */
  setSessionTimeout(timeout: number) : SessionHandler;

  /**
   * Set whether a nagging log warning should be written if the session handler is
   * accessed over HTTP, not HTTPS
   */
  setNagHttps(nag: boolean) : SessionHandler;

  /**
   * Sets whether the 'secure' flag should be set for the session cookie. When set
   * this flag instructs browsers to only send the cookie over HTTPS. Note that
   * this will probably stop your sessions working if used without HTTPS (e.g. in
   * development).
   */
  setCookieSecureFlag(secure: boolean) : SessionHandler;

  /**
   * Sets whether the 'HttpOnly' flag should be set for the session cookie. When
   * set this flag instructs browsers to prevent Javascript access to the the
   * cookie. Used as a line of defence against the most common XSS attacks.
   */
  setCookieHttpOnlyFlag(httpOnly: boolean) : SessionHandler;

  /**
   * Set the session cookie name
   */
  setSessionCookieName(sessionCookieName: string) : SessionHandler;

  /**
   * Set the session cookie path
   */
  setSessionCookiePath(sessionCookiePath: string) : SessionHandler;

  /**
   * Set expected session id minimum length.
   */
  setMinLength(minLength: number) : SessionHandler;

  /**
   * Set an auth provider that will allow retrieving the User object from the session to the current routing context.
   */
  setAuthProvider(authProvider: AuthProvider) : SessionHandler;
}

/**
 * A session store is used to store sessions for an Vert.x-Web web app
 */
export abstract class SessionStore {
  /**
   * Default length for a session id.
   * More info: https://www.owasp.org/index.php/Session_Management_Cheat_Sheet
   */
  static readonly DEFAULT_SESSIONID_LENGTH : number;

  /**
   * Create a Session store given a backend and configuration JSON.
   */
  static create(vertx: Vertx) : SessionStore;

  /**
   * Create a Session store given a backend and configuration JSON.
   */
  static create(vertx: Vertx, options: { [key: string]: any }) : SessionStore;

  /**
   * Initialize this store.
   */
  init(vertx: Vertx, options: { [key: string]: any }) : SessionStore;

  /**
   * The retry timeout value in milli seconds used by the session handler when it retrieves a value from the store.<p/>
   *
   * A non positive value means there is no retry at all.
   */
  retryTimeout() : number;

  /**
   * Create a new session using the default min length.
   */
  createSession(timeout: number) : Session;

  /**
   * Create a new session.
   */
  createSession(timeout: number, length: number) : Session;

  /**
   * Get the session with the specified ID.
   */
  get(cookieValue: string, resultHandler: ((res: AsyncResult<Session>) => void) | Handler<AsyncResult<Session>>) : void;

  /**
   * Delete the session with the specified ID.
   */
  delete(id: string, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Add a session with the specified ID.
   */
  put(session: Session, resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Remove all sessions from the store.
   */
  clear(resultHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   * Get the number of sessions in the store.
   * <p>
   * Beware of the result which is just an estimate, in particular with distributed session stores.
   */
  size(resultHandler: ((res: AsyncResult<number>) => void) | Handler<AsyncResult<number>>) : void;

  /**
   * Close the store
   */
  close() : void;
}

import { SockJSHandlerOptions } from './options';
import { BridgeOptions } from './options';

/**
 *
 * A handler that allows you to handle SockJS connections from clients.
 * <p>
 * We currently support version 0.3.3 of the SockJS protocol, which can be found in
 * <a href="https://github.com/sockjs/sockjs-protocol/tree/v0.3.3">this tag:</a>
 */
export abstract class SockJSHandler implements Handler<RoutingContext> {
  /**
   * Create a SockJS handler
   */
  static create(vertx: Vertx) : SockJSHandler;

  /**
   * Create a SockJS handler
   */
  static create(vertx: Vertx, options: SockJSHandlerOptions) : SockJSHandler;

  /**
   * Set a SockJS socket handler. This handler will be called with a SockJS socket whenever a SockJS connection
   * is made from a client
   */
  socketHandler(handler: ((res: SockJSSocket) => void) | Handler<SockJSSocket>) : Router;

  /**
   * Bridge the SockJS handler to the Vert.x event bus. This basically installs a built-in SockJS socket handler
   * which takes SockJS traffic and bridges it to the event bus, thus allowing you to extend the server-side
   * Vert.x event bus to browsers
   */
  bridge(bridgeOptions: BridgeOptions) : Router;

  /**
   * Like {@link SockJSHandler#bridge} but specifying a handler
   * that will receive bridge events.
   */
  bridge(bridgeOptions: BridgeOptions, bridgeEventHandler: ((res: BridgeEvent) => void) | Handler<BridgeEvent>) : Router;

  /**
   */
  handle(routingContext: RoutingContext) : void;
}

import { Pipe } from '@vertx/core';
import { WriteStream } from '@vertx/core';
import { ReadStream } from '@vertx/core';
import { SocketAddress } from '@vertx/core';

/**
 *
 * You interact with SockJS clients through instances of SockJS socket.
 * <p>
 * The API is very similar to {@link WebSocket}.
 * It implements both  and 
 * so it can be used with
 * {@link Pump} to pump data with flow control.<p>
 */
export abstract class SockJSSocket implements ReadStream<Buffer>, WriteStream<Buffer> {
  end(arg0: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  end(data: Buffer) : void;

  end(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  writeQueueFull() : boolean;

  fetch(arg0: number) : ReadStream<Buffer>;

  pipe() : Pipe<Buffer>;

  pipeTo(dst: WriteStream<Buffer>) : void;

  pipeTo(dst: WriteStream<Buffer>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : SockJSSocket;

  handler(handler: ((res: Buffer) => void) | Handler<Buffer> | null | undefined) : SockJSSocket;

  pause() : SockJSSocket;

  resume() : SockJSSocket;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : SockJSSocket;

  write(data: Buffer) : SockJSSocket;

  /**
   * Write a String to the socket, encoded in UTF-8.
   */
  write(data: string) : SockJSSocket;

  write(data: string, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : SockJSSocket;

  write(data: Buffer, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : SockJSSocket;

  setWriteQueueMaxSize(maxSize: number) : SockJSSocket;

  drainHandler(handler: ((res: void) => void) | Handler<void> | null | undefined) : SockJSSocket;

  /**
   * When a <code>SockJSSocket</code> is created it automatically registers an event handler with the event bus, the ID of that
   * handler is given by <code>writeHandlerID</code>.
   * <p>
   * Given this ID, a different event loop can send a buffer to that event handler using the event bus and
   * that buffer will be received by this instance in its own event loop and written to the underlying socket. This
   * allows you to write data to other sockets which are owned by different event loops.
   */
  writeHandlerID() : string;

  /**
   * Call {@link SockJSSocket#end}.
   */
  end() : void;

  /**
   * Close it
   */
  close() : void;

  /**
   * Close it giving a status code and reason. Only Applicable to RawWebSocket will downgrade to plain close for
   * other transports.
   */
  close(statusCode: number, reason: string) : void;

  /**
   * Return the remote address for this socket
   */
  remoteAddress() : SocketAddress;

  /**
   * Return the local address for this socket
   */
  localAddress() : SocketAddress;

  /**
   * Return the headers corresponding to the last request for this socket or the websocket handshake
   * Any cookie headers will be removed for security reasons
   */
  headers() : MultiMap;

  /**
   * Return the URI corresponding to the last request for this socket or the websocket handshake
   */
  uri() : string;

  /**
   */
  webSession() : Session | null;

  /**
   */
  webUser() : User | null;
}

import { Http2PushMapping } from './options';

/**
 * A handler for serving static resources from the file system or classpath.
 */
export abstract class StaticHandler implements Handler<RoutingContext> {
  /**
   * Default value of the web-root, where files are served from
   */
  static readonly DEFAULT_WEB_ROOT : string;

  /**
   * Default value of whether files are read -only and never will be updated
   */
  static readonly DEFAULT_FILES_READ_ONLY : boolean;

  /**
   * Default max age for cache headers
   */
  static readonly DEFAULT_MAX_AGE_SECONDS : number;

  /**
   * Default of whether cache header handling is enabled
   */
  static readonly DEFAULT_CACHING_ENABLED : boolean;

  /**
   * Default of whether directory listing is enabled
   */
  static readonly DEFAULT_DIRECTORY_LISTING : boolean;

  /**
   * Default template file to use for directory listing
   */
  static readonly DEFAULT_DIRECTORY_TEMPLATE : string;

  /**
   * Default of whether hidden files can be served
   */
  static readonly DEFAULT_INCLUDE_HIDDEN : boolean;

  /**
   * Default cache entry timeout, when caching
   */
  static readonly DEFAULT_CACHE_ENTRY_TIMEOUT : number;

  /**
   * The default index page
   */
  static readonly DEFAULT_INDEX_PAGE : string;

  /**
   * The default max cache size
   */
  static readonly DEFAULT_MAX_CACHE_SIZE : number;

  /**
   * Default of whether async filesystem access should always be used
   */
  static readonly DEFAULT_ALWAYS_ASYNC_FS : boolean;

  /**
   * Default of whether fs async/sync tuning should be used
   */
  static readonly DEFAULT_ENABLE_FS_TUNING : boolean;

  /**
   * Default max avg serve time, in ns, over which serving will be considered slow
   */
  static readonly DEFAULT_MAX_AVG_SERVE_TIME_NS : number;

  /**
   * Default of whether Range request handling support should be used
   */
  static readonly DEFAULT_RANGE_SUPPORT : boolean;

  /**
   * Default of whether access to the root of the file system should be allowed or just allow from the current working
   * directory.
   */
  static readonly DEFAULT_ROOT_FILESYSTEM_ACCESS : boolean;

  /**
   * Default of whether vary header should be sent.
   */
  static readonly DEFAULT_SEND_VARY_HEADER : boolean;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler using defaults
   */
  static create() : StaticHandler;

  /**
   * Create a handler, specifying web-root
   */
  static create(root: string) : StaticHandler;

  /**
   * Enable/Disable access to the root of the filesystem
   */
  setAllowRootFileSystemAccess(allowRootFileSystemAccess: boolean) : StaticHandler;

  /**
   * Set the web root
   */
  setWebRoot(webRoot: string) : StaticHandler;

  /**
   * Set whether files are read-only and will never change
   */
  setFilesReadOnly(readOnly: boolean) : StaticHandler;

  /**
   * Set value for max age in caching headers
   */
  setMaxAgeSeconds(maxAgeSeconds: number) : StaticHandler;

  /**
   * Set whether cache header handling is enabled
   */
  setCachingEnabled(enabled: boolean) : StaticHandler;

  /**
   * Set whether directory listing is enabled
   */
  setDirectoryListing(directoryListing: boolean) : StaticHandler;

  /**
   * Set whether hidden files should be served
   */
  setIncludeHidden(includeHidden: boolean) : StaticHandler;

  /**
   * Set the server cache entry timeout when caching is enabled
   */
  setCacheEntryTimeout(timeout: number) : StaticHandler;

  /**
   * Set the index page
   */
  setIndexPage(indexPage: string) : StaticHandler;

  /**
   * Set the max cache size, when caching is enabled
   */
  setMaxCacheSize(maxCacheSize: number) : StaticHandler;

  /**
   * Set the file mapping for http2push and link preload
   */
  setHttp2PushMapping(http2PushMappings: Http2PushMapping[]) : StaticHandler;

  /**
   * Skip compression if the media type of the file to send is in the provided <code>mediaTypes</code> set.
   * <code>Content-Encoding</code> header set to <code>identity</code> for the types present in the <code>mediaTypes</code> set
   */
  skipCompressionForMediaTypes(mediaTypes: string[]) : StaticHandler;

  /**
   * Skip compression if the suffix of the file to send is in the provided <code>fileSuffixes</code> set.
   * <code>Content-Encoding</code> header set to <code>identity</code> for the suffixes present in the <code>fileSuffixes</code> set
   */
  skipCompressionForSuffixes(fileSuffixes: string[]) : StaticHandler;

  /**
   * Set whether async filesystem access should always be used
   */
  setAlwaysAsyncFS(alwaysAsyncFS: boolean) : StaticHandler;

  /**
   * Set whether async/sync filesystem tuning should enabled
   */
  setEnableFSTuning(enableFSTuning: boolean) : StaticHandler;

  /**
   * Set the max serve time in ns, above which serves are considered slow
   */
  setMaxAvgServeTimeNs(maxAvgServeTimeNanoSeconds: number) : StaticHandler;

  /**
   * Set the directory template to be used when directory listing
   */
  setDirectoryTemplate(directoryTemplate: string) : StaticHandler;

  /**
   * Set whether range requests (resumable downloads; media streaming) should be enabled.
   */
  setEnableRangeSupport(enableRangeSupport: boolean) : StaticHandler;

  /**
   * Set whether vary header should be sent with response.
   */
  setSendVaryHeader(varyHeader: boolean) : StaticHandler;

  /**
   * Set the default content encoding for text related files. This allows overriding the system settings default value.
   */
  setDefaultContentEncoding(contentEncoding: string) : StaticHandler;
}

import { TemplateEngine as TemplateEngineSuper } from '@vertx/web-common';

/**
 * A template engine uses a specific template and the data in a routing context to render a resource into a buffer.
 * <p>
 * Concrete implementations exist for several well-known template engines.
 */
export abstract class TemplateEngine extends TemplateEngineSuper {
  /**
   * Render the template
   */
  render(context: RoutingContext, templateFileName: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : void;

  /**
   * Render the template
   * <p>
   * <b>NOTE</b> if you call method directly (i.e. not using {@link TemplateHandler}) make sure
   * that <i>templateFileName</i> is sanitized via 
   */
  render(context: RoutingContext, templateDirectory: string, templateFileName: string, handler: ((res: AsyncResult<Buffer>) => void) | Handler<AsyncResult<Buffer>>) : void;

  /**
   * Returns true if the template engine caches template files. If false, then template files are freshly loaded each
   * time they are used.
   */
  isCachingEnabled() : boolean;
}

/**
 *
 * A handler which renders responses using a template engine and where the template name is selected from the URI
 * path.
 */
export abstract class TemplateHandler implements Handler<RoutingContext> {
  /**
   * The default directory where templates will be looked for
   */
  static readonly DEFAULT_TEMPLATE_DIRECTORY : string;

  /**
   * The default content type header to be used in the response
   */
  static readonly DEFAULT_CONTENT_TYPE : string;

  /**
   * The default index page
   */
  static readonly DEFAULT_INDEX_TEMPLATE : string;

  handle(arg0: RoutingContext) : void;

  /**
   * Set the index template
   */
  setIndexTemplate(indexTemplate: string) : TemplateHandler;

  /**
   * Create a handler
   */
  static create(engine: TemplateEngine) : TemplateHandler;

  /**
   * Create a handler
   */
  static create(engine: TemplateEngine, templateDirectory: string, contentType: string) : TemplateHandler;
}

/**
 * Handler that will timeout requests if the response has not been written after a certain time.
 * Timeout requests will be ended with an HTTP status code `503`.
 */
export abstract class TimeoutHandler implements Handler<RoutingContext> {
  /**
   * The default timeout, in ms
   */
  static readonly DEFAULT_TIMEOUT : number;

  /**
   * The default error code
   */
  static readonly DEFAULT_ERRORCODE : number;

  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler
   */
  static create() : TimeoutHandler;

  /**
   * Create a handler
   */
  static create(timeout: number) : TimeoutHandler;

  /**
   * Create a handler
   */
  static create(timeout: number, errorCode: number) : TimeoutHandler;
}

/**
 *
 * This handler should be used if you want to store the User object in the Session so it's available between
 * different requests, without you having re-authenticate each time.
 *
 * It requires that the session handler is already present on previous matching routes.
 *
 * It requires an Auth provider so, if the user is deserialized from a clustered session it knows which Auth provider
 * to associate the session with.
 */
export abstract class UserSessionHandler implements Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Create a new handler
   */
  static create(authProvider: AuthProvider) : UserSessionHandler;
}

/**
 * Handler that will filter requests based on the request Host name.
 */
export abstract class VirtualHostHandler implements Handler<RoutingContext> {
  handle(arg0: RoutingContext) : void;

  /**
   * Create a handler
   */
  static create(hostname: string, handler: ((res: RoutingContext) => void) | Handler<RoutingContext>) : VirtualHostHandler;
}
