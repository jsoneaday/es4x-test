/*
 * Copyright 2020 ES4X
 *
 * ES4X licenses this file to you under the Apache License, version 2.0
 * (the "License"); you may not use this file except in compliance with the
 * License.  You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

import { Handler, AsyncResult } from '@vertx/core';

import { Promise } from '@vertx/core';

/**
 * An asynchronous exit point for a test.<p/>
 */
export abstract class Async extends Completion<void> {
  /**
   * Completes the future upon completion, otherwise fails it.
   */
  resolve(future: Promise<void>) : void;

  /**
   * Completion handler to receive a completion signal when this completions completes.
   */
  handler(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   */
  count() : number;

  /**
   * Count down the async.
   */
  countDown() : void;

  /**
   * Signals the asynchronous operation is done, this method must be called with a count greater than <code>0</code>,
   * otherwise it throws an <code>IllegalStateException</code> to signal the error.
   */
  complete() : void;
}

/**
 * A completion object that emits completion notifications either <i>succeeded</i> or <i>failed</i>.
 */
export abstract class Completion<T> {
  /**
   * Completes the future upon completion, otherwise fails it.
   */
  resolve(future: Promise<T>) : void;

  /**
   */
  isCompleted() : boolean;

  /**
   */
  isSucceeded() : boolean;

  /**
   */
  isFailed() : boolean;

  /**
   * Completion handler to receive a completion signal when this completions completes.
   */
  handler(completionHandler: ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>) : void;

  /**
   * Cause the current thread to wait until this completion completes.<p/>
   *
   * If the current thread is interrupted, an exception will be thrown.
   */
  await() : void;

  /**
   * Cause the current thread to wait until this completion completes with a configurable timeout.<p/>
   *
   * If completion times out or the current thread is interrupted, an exception will be thrown.
   */
  await(timeoutMillis: number) : void;

  /**
   * Cause the current thread to wait until this completion completes and succeeds.<p/>
   *
   * If the current thread is interrupted or the suite fails, an exception will be thrown.
   */
  awaitSuccess() : void;

  /**
   * Cause the current thread to wait until this completion completes and succeeds with a configurable timeout.<p/>
   *
   * If completion times out or the current thread is interrupted or the suite fails, an exception will be thrown.
   */
  awaitSuccess(timeoutMillis: number) : void;
}

import { Vertx } from '@vertx/core';
import { MessageConsumer } from '@vertx/core';
import { ReportingOptions } from './options';

/**
 * The event bus collector listen to events on the Vert.x event bus and translate them
 * into reports.
 */
export abstract class EventBusCollector {
  /**
   * Json <code>type</code> field value that signals a test suite begins, used as part of the test reporting
   * protocol for the event bus.
   */
  static readonly EVENT_TEST_SUITE_BEGIN : string;

  /**
   * Json <code>type</code> field value that signals a test suite ends, used as part of the test reporting
   * protocol for the event bus.
   */
  static readonly EVENT_TEST_SUITE_END : string;

  /**
   * Json <code>type</code> field value that reports a test suite error, used as part of the test reporting
   * protocol for the event bus.
   */
  static readonly EVENT_TEST_SUITE_ERROR : string;

  /**
   * Json <code>type</code> field value that signals a test case begins, used as part of the test reporting
   * protocol for the event bus.
   */
  static readonly EVENT_TEST_CASE_BEGIN : string;

  /**
   * Json <code>type</code> field value that signals a test case ends, used as part of the test reporting
   * protocol for the event bus.
   */
  static readonly EVENT_TEST_CASE_END : string;

  /**
   * Create a message handler reporting with the specified options. The returned
   * message handler can be registered to an event bus.
   */
  static create(vertx: Vertx, options: ReportingOptions) : EventBusCollector;

  static create(vertx: Vertx, reporter: ((res: TestSuiteReport) => void) | Handler<TestSuiteReport>) : EventBusCollector;

  /**
   * Register the collector as a consumer of the event bus with the specified address.
   */
  register(address: string) : MessageConsumer<any>;
}

/**
 * A failure provides the details of a failure that happened during the execution of a test case.<p/>
 *
 * The failure can be:
 * <ul>
 *   <li>an assertion failure: an assertion failed</li>
 *   <li>an error failure: an expected error occured</li>
 * </ul>
 */
export abstract class Failure {
  /**
   */
  isError() : boolean;

  /**
   */
  message() : string;

  /**
   */
  stackTrace() : string;
}

/**
 * A test case object can be used to create a single test.
 */
export abstract class TestCase {
  /**
   * Create a test case.
   */
  static create(name: string, testCase: ((res: TestContext) => void) | Handler<TestContext>) : TestCase;
}

/**
 * Report the execution of a test case.
 */
export abstract class TestCaseReport {
  /**
   */
  name() : string;

  /**
   * Set a callback for completion, the specified <code>handler</code> is invoked when the test exec has completed.
   */
  endHandler(handler: ((res: TestResult) => void) | Handler<TestResult>) : TestCaseReport;
}

/**
 * This object provides callback-ability for the end of a test suite, the completion <i>succeeds</i>
 * when all tests pass otherwise it fails.
 */
export abstract class TestCompletion extends Completion<void> {
  /**
   * Completes the future upon completion, otherwise fails it.
   */
  resolve(future: Promise<void>) : void;

  /**
   * Completion handler to receive a completion signal when this completions completes.
   */
  handler(completionHandler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;
}

/**
 * The test context is used for performing test assertions and manage the completion of the test. This context
 * is provided by <i>vertx-unit</i> as argument of the test case.
 */
export abstract class TestContext {
  /**
   * Get some data from the context.
   */
  get<T>(key: string) : T;

  /**
   * Put some data in the context.
   * <p>
   * This can be used to share data between different tests and before/after phases.
   */
  put<T>(key: string, value: any) : T;

  /**
   * Remove some data from the context.
   */
  remove<T>(key: string) : T;

  /**
   * Assert the <code>expected</code> argument is <code>null</code>. If the argument is not, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertNull(expected: any) : TestContext;

  /**
   * Assert the <code>expected</code> argument is <code>null</code>. If the argument is not, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertNull(expected: any, message: string) : TestContext;

  /**
   * Assert the <code>expected</code> argument is not <code>null</code>. If the argument is <code>null</code>, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertNotNull(expected: any) : TestContext;

  /**
   * Assert the <code>expected</code> argument is not <code>null</code>. If the argument is <code>null</code>, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertNotNull(expected: any, message: string) : TestContext;

  /**
   * Assert the specified <code>condition</code> is <code>true</code>. If the condition is <code>false</code>, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertTrue(condition: boolean) : TestContext;

  /**
   * Assert the specified <code>condition</code> is <code>true</code>. If the condition is <code>false</code>, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertTrue(condition: boolean, message: string) : TestContext;

  /**
   * Assert the specified <code>condition</code> is <code>false</code>. If the condition is <code>true</code>, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertFalse(condition: boolean) : TestContext;

  /**
   * Assert the specified <code>condition</code> is <code>false</code>. If the condition is <code>true</code>, an assertion error is thrown
   * otherwise the execution continue.
   */
  assertFalse(condition: boolean, message: string) : TestContext;

  /**
   * Assert the <code>expected</code> argument is equals to the <code>actual</code> argument. If the arguments are not equals
   * an assertion error is thrown otherwise the execution continue.
   */
  assertEquals(expected: any, actual: any) : TestContext;

  /**
   * Assert the <code>expected</code> argument is equals to the <code>actual</code> argument. If the arguments are not equals
   * an assertion error is thrown otherwise the execution continue.
   */
  assertEquals(expected: any, actual: any, message: string) : TestContext;

  /**
   * Asserts that the <code>expected</code> double argument is equals to the <code>actual</code> double argument
   * within a positive delta. If the arguments do not satisfy this, an assertion error is thrown otherwise
   * the execution continue.
   */
  assertInRange(expected: number, actual: number, delta: number) : TestContext;

  /**
   * Asserts that the <code>expected</code> double argument is equals to the <code>actual</code> double argument
   * within a positive delta. If the arguments do not satisfy this, an assertion error is thrown otherwise
   * the execution continue.
   */
  assertInRange(expected: number, actual: number, delta: number, message: string) : TestContext;

  /**
   * Assert the <code>first</code> argument is not equals to the <code>second</code> argument. If the arguments are equals
   * an assertion error is thrown otherwise the execution continue.
   */
  assertNotEquals(first: any, second: any) : TestContext;

  /**
   * Assert the <code>first</code> argument is not equals to the <code>second</code> argument. If the arguments are equals
   * an assertion error is thrown otherwise the execution continue.
   */
  assertNotEquals(first: any, second: any, message: string) : TestContext;

  /**
   * Execute the provided handler, which may contain assertions, possibly from any third-party assertion framework.
   * Any AssertionError thrown will be caught (and propagated) in order to fulfill potential expected async
   * completeness.
   */
  verify(block: ((res: void) => void) | Handler<void>) : TestContext;

  /**
   * Throw a failure.
   */
  fail() : void;

  /**
   * Throw a failure with the specified failure <code>message</code>.
   */
  fail(message: string) : void;

  /**
   * Throw a failure with the specified failure <code>cause</code>.
   */
  fail(cause: Error) : void;

  /**
   * Create and returns a new async object, the returned async controls the completion of the test. Calling the
   * {@link Async#complete} completes the async operation.<p/>
   *
   * The test case will complete when all the async objects have their {@link Async#complete}
   * method called at least once.<p/>
   *
   * This method shall be used for creating asynchronous exit points for the executed test.
   */
  async() : Async;

  /**
   * Create and returns a new async object, the returned async controls the completion of the test. This async operation
   * completes when the {@link Async#countDown} is called <code>count</code> times.<p/>
   *
   * The test case will complete when all the async objects have their {@link Async#complete}
   * method called at least once.<p/>
   *
   * This method shall be used for creating asynchronous exit points for the executed test.<p/>
   */
  async(count: number) : Async;

  /**
   * Create and returns a new async object, the returned async controls the completion of the test.
   * This async operation completes when the {@link Async#countDown} is called <code>count</code> times.<p/>
   * If {@link Async#countDown} is called more than <code>count</code> times, an IllegalStateException is thrown.<p/>
   *
   * The test case will complete when all the async objects have their {@link Async#complete}
   * method called at least once.<p/>
   *
   * This method shall be used for creating asynchronous exit points for the executed test.<p/>
   */
  strictAsync(count: number) : Async;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   *
   * When the returned handler is called back with a succeeded result it completes the async operation.<p/>
   *
   * When the returned handler is called back with a failed result it fails the test with the cause of the failure.<p/>
   */
  asyncAssertSuccess<T>() : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   *
   * When the returned handler is called back with a succeeded result it invokes the <code>resultHandler</code> argument
   * with the async result. The test completes after the result handler is invoked and does not fails.<p/>
   *
   * When the returned handler is called back with a failed result it fails the test with the cause of the failure.<p/>
   *
   * Note that the result handler can create other async objects during its invocation that would postpone
   * the completion of the test case until those objects are resolved.
   */
  asyncAssertSuccess<T>(resultHandler: ((res: T) => void) | Handler<T>) : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   *
   * When the returned handler is called back with a failed result it completes the async operation.<p/>
   *
   * When the returned handler is called back with a succeeded result it fails the test.<p/>
   */
  asyncAssertFailure<T>() : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   * Creates and returns a new async handler, the returned handler controls the completion of the test.<p/>
   *
   * When the returned handler is called back with a failed result it completes the async operation.<p/>
   *
   * When the returned handler is called back with a succeeded result it fails the test.<p/>
   */
  asyncAssertFailure<T>(causeHandler: ((res: Error) => void) | Handler<Error>) : ((res: AsyncResult<T>) => void) | Handler<AsyncResult<T>>;

  /**
   */
  exceptionHandler() : ((res: Error) => void) | Handler<Error>;
}

/**
 * The result of a test.
 */
export abstract class TestResult {
  /**
   * The test description, may be null if none was provided.
   */
  name() : string;

  /**
   * The time at which the test began in millis.
   */
  beginTime() : number;

  /**
   * How long the test lasted in millis.
   */
  durationTime() : number;

  /**
   * Did it succeed?
   */
  succeeded() : boolean;

  /**
   * Did it fail?
   */
  failed() : boolean;

  /**
   * An exception describing failure, null if the test succeeded.
   */
  failure() : Failure;
}

import { TestOptions } from './options';

/**
 * A named suite of test cases that are executed altogether. The suite suite is created with
 * the {@link TestSuite#create} and the returned suite contains initially no tests.<p/>
 *
 * The suite can declare a callback before the suite with {@link TestSuite#before} or after
 * the suite with {@link TestSuite#after}.<p/>
 *
 * The suite can declare a callback before each test with {@link TestSuite#beforeEach} or after
 * each test with {@link TestSuite#afterEach}.<p/>
 *
 * Each test case of the suite is declared by calling the {@link TestSuite#test} method.
 */
export abstract class TestSuite {
  /**
   * Create and return a new test suite.
   */
  static create(name: string) : TestSuite;

  /**
   * Set a callback executed before the tests.
   */
  before(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Set a callback executed before each test and after the suite <code>before</code> callback.
   */
  beforeEach(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Set a callback executed after the tests.
   */
  after(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Set a callback executed after each test and before the suite <code>after</code> callback.
   */
  afterEach(callback: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Add a new test case to the suite.
   */
  test(name: string, testCase: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Add a new test case to the suite.
   */
  test(name: string, repeat: number, testCase: ((res: TestContext) => void) | Handler<TestContext>) : TestSuite;

  /**
   * Run the testsuite with the default options.<p/>
   *
   * When the test suite is executed in a Vertx context (i.e `Vertx.currentContext()` returns a context) this
   * context's event loop is used for running the test suite. Otherwise it is executed in the current thread.<p/>
   *
   * The returned {@link Completion} object can be used to get a completion callback.
   */
  run() : TestCompletion;

  /**
   * Run the testsuite with the specified <code>options</code>.<p/>
   *
   * When the test suite is executed in a Vertx context (i.e `Vertx.currentContext()` returns a context) this
   * context's event loop is used for running the test suite unless the <a href="../../dataobjects.html#TestOptions">TestOptions</a>
   * is set to <code>false</code>. In this case it is executed by the current thread.<p/>
   *
   * Otherwise, the test suite will be executed in the current thread when <a href="../../dataobjects.html#TestOptions">TestOptions</a> is
   * set to <code>false</code> or <code>null</code>. If the value is <code>true</code>, this methods throws an <code>IllegalStateException</code>.<p/>
   *
   * The returned {@link Completion} object can be used to get a completion callback.
   */
  run(options: TestOptions) : TestCompletion;

  /**
   * Run the testsuite with the default options and the specified <code>vertx</code> instance.<p/>
   *
   * The test suite will be executed on the event loop provided by the <code>vertx</code> argument. The returned
   * {@link Completion} object can be used to get a completion callback.<p/>
   */
  run(vertx: Vertx) : TestCompletion;

  /**
   * Run the testsuite with the specified <code>options</code> and the specified <code>vertx</code> instance.<p/>
   *
   * The test suite will be executed on the event loop provided by the <code>vertx</code> argument when
   * <a href="../../dataobjects.html#TestOptions">TestOptions</a> is not set to <code>false</code>. The returned
   * {@link Completion} object can be used to get a completion callback.
   */
  run(vertx: Vertx, options: TestOptions) : TestCompletion;
}

import { Pipe } from '@vertx/core';
import { WriteStream } from '@vertx/core';
import { ReadStream } from '@vertx/core';

/**
 * The test suite reports is basically a stream of events reporting the test suite execution.
 */
export abstract class TestSuiteReport implements ReadStream<TestCaseReport> {
  fetch(arg0: number) : ReadStream<TestCaseReport>;

  pipe() : Pipe<TestCaseReport>;

  pipeTo(dst: WriteStream<TestCaseReport>) : void;

  pipeTo(dst: WriteStream<TestCaseReport>, handler: ((res: AsyncResult<void>) => void) | Handler<AsyncResult<void>>) : void;

  /**
   */
  name() : string;

  /**
   * Set an exception handler, the exception handler reports the test suite errors, it can be called mulitple
   * times before the test ends.
   */
  exceptionHandler(handler: ((res: Error) => void) | Handler<Error> | null | undefined) : TestSuiteReport;

  handler(handler: ((res: TestCaseReport) => void) | Handler<TestCaseReport> | null | undefined) : TestSuiteReport;

  pause() : TestSuiteReport;

  resume() : TestSuiteReport;

  endHandler(endHandler: ((res: void) => void) | Handler<void> | null | undefined) : TestSuiteReport;
}
